function [trials, ir] = abet2mat(xml, csv)
%ABET2MAT Convert data in XML and CSV files from ABET II to MAT.
%   [trials,ir] = ABET2MAT('data.xml','data.csv') converts the XML file
%   generated by 'PD Analysis' in ABET II to a cell array containing information
%   on trials and rewards. It also pulls info of infrared (IR) beam breaks and
%   inter-time interval (ITI) touches from the CSV file.
%
%   Outputs:
%       trials - Data on any trials, reward collections, or ITI touches
%           Column 1: trial, reward, or touch
%           Column 2: regular or correction trials, NaN for reward and
%           touch
%           Column 3: correct or incorrect trial, NaN for reward and touch
%           Column 4: left, right, or unknown side for screen touch, NaN
%           for reward
%           Column 5: event start time (seconds)
%           Column 6: event end time (seconds)
%           Column 7: event duration (seconds)
%       ir - Data on infrared (IR) beam breaks
%           Column 1: front or back IR beam
%           Column 2: event start time (seconds)
%           Column 3: event end time (seconds)
%           Column 4: event duration (seconds)
%
%   EXAMPLE:
%       [trials,ir] = ABET2MAT('data.xml','data.csv')

temp = cell(10,4);
temp(:,1) = {'Trials Completed'; 'No Correction Trials'; '% Correct';
    'Left ITI Touches'; 'Right ITI Touches'; 'Correct Reward Collection';
    'Correct Left touch latency'; 'Correct Right touch latency';
    'Incorrect Touch Latency'; 'Correct touch latency'};

% "PD Analysis" Bug: if trials ends in a regular incorrect, add an
% uncompleted correction trial to the total count
% Bug: Trials completed == number of rewards collected, not images touched
% A trial is only considered completed if the final reward is collected

% IMPORT XML
f = fopen(xml,'r');
d = textscan(f,'%s','Delimiter','');
d = d{1};
fclose(f);

% metrics from xml analysis
temp{1,2} = xml_find(d, 2, '<Name>End Summary - Trials Completed</Name>', ...
    {'<Results>','</Results>'});
temp{2,2} = xml_find(d, 2, '<Name>End Summary - No Correction Trials</Name>', ...
    {'<Results>','</Results>'});
temp{3,2} = xml_find(d, 2, '<Name>End Summary - % Correct</Name>', ...
    {'<Results>','</Results>'});
temp{4,2} = xml_find(d, 2, '<Name>End Summary - Left ITI Touches</Name>', ...
    {'<Results>','</Results>'});
temp{5,2} = xml_find(d, 2, '<Name>End Summary - Right ITI Touches</Name>', ...
    {'<Results>','</Results>'});

% metrics from xml events
temp{6,2} = sum(strcmp(d, '<Name>Correct Reward Collection</Name>'));
temp{7,2} = sum(strcmp(d, '<Name>Correct Left touch latency</Name>'));
temp{8,2} = sum(strcmp(d, '<Name>Correct Right touch latency</Name>'));
temp{9,2} = sum(strcmp(d, '<Name>Incorrect Touch Latency</Name>'));
temp{10,2} = sum(strcmp(d, '<Name>Correct touch latency</Name>'));

% Latencies
% time -> image displayed time
% time + duration -> image touch time
% duration -> latency from image display to image touch

% Collection
% Time -> image touched/reward dispensed
% time + duration -> reward collected

temp{6,3} = xml_find(d, 2, '<Name>Correct Reward Collection</Name>', ...
    {'<Time>','</Time>'})./(10^6);
temp{7,3} = xml_find(d, 2, '<Name>Correct Left touch latency</Name>', ...
    {'<Time>','</Time>'})./(10^6);
temp{8,3} = xml_find(d, 2, '<Name>Correct Right touch latency</Name>', ...
    {'<Time>','</Time>'})./(10^6);
temp{9,3} = xml_find(d, 2, '<Name>Incorrect Touch Latency</Name>', ...
    {'<Time>','</Time>'})./(10^6);
temp{10,3} = xml_find(d, 2, '<Name>Correct touch latency</Name>', ...
    {'<Time>','</Time>'})./(10^6);

temp{6,4} = xml_find(d, 3, '<Name>Correct Reward Collection</Name>', ...
    {'<Duration>','</Duration>'})./(10^6);
temp{7,4} = xml_find(d, 3, '<Name>Correct Left touch latency</Name>', ...
    {'<Duration>','</Duration>'})./(10^6);
temp{8,4} = xml_find(d, 3, '<Name>Correct Right touch latency</Name>', ...
    {'<Duration>','</Duration>'})./(10^6);
temp{9,4} = xml_find(d, 3, '<Name>Incorrect Touch Latency</Name>', ...
    {'<Duration>','</Duration>'})./(10^6);
temp{10,4} = xml_find(d, 3, '<Name>Correct touch latency</Name>', ...
    {'<Duration>','</Duration>'})./(10^6);

% reward(0)/trial(1), regular/correction, correct(1)/incorrect(0),
% left(0)/right(1)/unknown(2), start time (double), end time (double), duration
% (double)
% NaN - do not fill
% Inf - unknown value

trials = [
        [ones(temp{7,2},1) Inf(temp{7,2},1) ones(temp{7,2},1) ...
        zeros(temp{7,2},1) temp{7,3} temp{7,3}+temp{7,4} temp{7,4}]; % left touch
        [ones(temp{8,2},1) Inf(temp{8,2},1) ones(temp{8,2},1) ...
        ones(temp{8,2},1) temp{8,3} temp{8,3}+temp{8,4} temp{8,4}]; % right touch
        [ones(temp{9,2},1) Inf(temp{9,2},1) zeros(temp{9,2},1) ...
        ones(temp{9,2},1).*2 temp{9,3} temp{9,3}+temp{9,4} temp{9,4}]; % incorrect touch
        ];

trials = sortrows(trials,5); % sort by start time

% determine regular(0)/correction(1) trials based on correct/incorrect
if size(trials,1) > 0
    t = 0; % first trial is always a regular trial
end

if size(trials,1) > 1
    for k = 1:size(trials,1)-1
        switch trials(k,3)
            case 0 % incorrect
                t = [t; 1];
            case 1 % correct
                t = [t; 0];
        end
    end
end

if size(trials,1) > 0
    trials(:,2) = t;
end

% add reward collection
trials = [trials;
        [zeros(temp{6,2},1) NaN(temp{6,2},1) NaN(temp{6,2},1) ...
        NaN(temp{6,2},1) temp{6,3} temp{6,3}+temp{6,4} temp{6,4}]; % reward collect
        ];

trials = sortrows(trials,5); % sort by start time
trials = num2cell(trials);

% apply strings to numeric labels
for k = 1:size(trials,1)
    switch trials{k,1}
        case 0
            trials{k,1} = 'reward';
        case 1
            trials{k,1} = 'trial';
    end

    switch trials{k,2}
        case 0
            trials{k,2} = 'regular';
        case 1
            trials{k,2} = 'correction';
    end

    switch trials{k,3}
        case 0
            trials{k,3} = 'incorrect';
        case 1
            trials{k,3} = 'correct';
    end

    switch trials{k,4}
        case 0
            trials{k,4} = 'left';
        case 1
            trials{k,4} = 'right';
        case 2
            trials{k,4} = 'unknown';
    end
end

% IMPORT CSV
c = import_csv(csv);

% ITI touches
touch = c((cell2mat(c(:,1)) ~= 0) & strcmp(c(:,2),'Variable Event') & ...
    (strcmp(c(:,3), 'Right_touches_during_ITI') | strcmp(c(:,3), ...
    'Left_Touches_during_ITI')),:);
for k = 1:size(touch,1)
    switch touch{k,3}
        case 'Left_Touches_during_ITI'
            touch_dir = 'left';
        case 'Right_touches_during_ITI'
            touch_dir = 'right';
    end

    trials = [trials; {'touch' NaN NaN touch_dir touch{k,1} NaN NaN}];
end

trials = sortrows(trials,5); % sort by start time

% IR beam breaks
f_ir = c((cell2mat(c(:,1)) ~= 0) & (strcmp(c(:,2),'Input Transition On Event') | ...
        strcmp(c(:,2),'Input Transition Off Event')) & ...
        strcmp(c(:,3),'FIRBeam #1'),:);

b_ir = c((cell2mat(c(:,1)) ~= 0) & (strcmp(c(:,2),'Input Transition On Event') | ...
        strcmp(c(:,2),'Input Transition Off Event')) & ...
        strcmp(c(:,3),'BIRBeam #1'),:);

% discard unpaired 'off' or unpaired 'on'
if ~isempty(f_ir)
    if strcmp(f_ir{1,2},'Input Transition Off Event')
        f_ir = f_ir(2:end,:);
    end

    if strcmp(f_ir{end,2},'Input Transition On Event')
        f_ir = f_ir(1:(end-1),:);
    end
end

if ~isempty(b_ir)
    if strcmp(b_ir{1,2},'Input Transition Off Event')
        b_ir = b_ir(2:end,:);
    end

    if strcmp(b_ir{end,2},'Input Transition On Event')
        b_ir = b_ir(1:(end-1),:);
    end
end

% calculate durations
ir = [];
for k = 1:size(f_ir,1)-1
    ir = [ir; {'front' f_ir{k,1} f_ir{k+1,1} f_ir{k+1,1}-f_ir{k,1}}];
end

for k = 1:size(b_ir,1)-1
    ir = [ir; {'back' b_ir{k,1} b_ir{k+1,1} b_ir{k+1,1}-b_ir{k,1}}];
end

if ~isempty(ir)
    ir = sortrows(ir,2);
end
end

% -------------------------------------------------------------------------
function n = xml_find(xml, j, h, e)
    i0 = strcmp(xml, h);
    index = find(i0);
    i0(index) = 0;
    i0(index+j) = 1;

    n = xml(i0);
    n = str2double(erase(n,e));
end

% -------------------------------------------------------------------------
function csv = import_csv(filename)
    % Initialize variables.
    delimiter = ',';
    startRow = 19;
    endRow = inf;

    % Format for each line of text:
    formatSpec = '%f%*s%s%s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%[^\n\r]';

    % Open the text file.
    fileID = fopen(filename,'r');

    % Read columns of data according to the format.
    textscan(fileID, '%[^\n\r]', startRow(1)-1, ...
        'WhiteSpace', '', 'ReturnOnError', false);
    dataArray = textscan(fileID, formatSpec, ...
        endRow(1)-startRow(1)+1, 'Delimiter', delimiter, ...
        'TextType', 'string', 'EmptyValue', NaN, 'ReturnOnError', ...
        false, 'EndOfLine', '\r\n');
    for block=2:length(startRow)
        frewind(fileID);
        textscan(fileID, '%[^\n\r]', startRow(block)-1, 'WhiteSpace', '', ...
            'ReturnOnError', false);
        dataArrayBlock = textscan(fileID, formatSpec, ...
            endRow(block)-startRow(block)+1, 'Delimiter', ...
            delimiter, 'TextType', 'string', 'EmptyValue', NaN, ...
            'ReturnOnError', false, 'EndOfLine', '\r\n');
        for col=1:length(dataArray)
            dataArray{col} = [dataArray{col};dataArrayBlock{col}];
        end
    end

    % Close the text file.
    fclose(fileID);

    % Create output variable
    csv = [dataArray{1:end-1}];

    temp = cell(size(csv,1), size(csv,2));
    for i = 1:size(csv,1)
        temp{i,1} = str2double(csv(i,1));
        temp{i,2} = char(csv(i,2));
        temp{i,3} = char(csv(i,3));
    end

    csv = temp;
end
